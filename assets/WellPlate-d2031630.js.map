{"version":3,"file":"WellPlate-d2031630.js","sources":["../../node_modules/react/cjs/react-jsx-runtime.production.min.js","../../node_modules/react/jsx-runtime.js","../../node_modules/well-plates/lib-es6/utils.js","../../node_modules/well-plates/lib-es6/index.js","../../src/util/Well.tsx","../../src/util/WellPlateInternal.tsx","../../src/WellPicker.tsx","../../src/WellPlate.tsx"],"sourcesContent":["/** @license React v17.0.2\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';require(\"object-assign\");var f=require(\"react\"),g=60103;exports.Fragment=60107;if(\"function\"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h(\"react.element\");exports.Fragment=h(\"react.fragment\")}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=\"\"+k);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","export function getRange(start, size) {\n    const result = [];\n    for (let i = 0; i < size; i++) {\n        result[i] = start + i;\n    }\n    return result;\n}\n","import { getRange } from './utils';\n/**\n * The format of a well position.\n */\nexport var PositionFormat;\n(function (PositionFormat) {\n    /**\n     * Sequential. When this format is used, the position code will starts with 1 and will be incremented columns first.\n     */\n    PositionFormat[\"Sequential\"] = \"SEQUENTIAL\";\n    /**\n     * A letter + a number. When this format is used, the position will be represented\n     * as a string with one letter + one number, representing the row and column position. For example B3 is for second row, 3rd column.\n     */\n    PositionFormat[\"LetterNumber\"] = \"LETTER_NUMBER\";\n    /**\n     * A number + a number. When this format is used, the position will be represented\n     * as number for the row and a number for the column. For example 2-4 is for secord row, 4th column.\n     */\n    PositionFormat[\"NumberNumber\"] = \"NUMBER_NUMBER\";\n})(PositionFormat || (PositionFormat = {}));\n/**\n * The iteration order\n * Determines in which order iteration over wells is performed\n */\nexport var IterationOrder;\n(function (IterationOrder) {\n    /**\n     * Jump from one column to the next when iterating\n     */\n    IterationOrder[\"ByColumn\"] = \"BY_COLUMN\";\n    /**\n     * Jump from one row to the next when iterating\n     */\n    IterationOrder[\"ByRow\"] = \"BY_ROW\";\n})(IterationOrder || (IterationOrder = {}));\nexport var SubsetMode;\n(function (SubsetMode) {\n    /**\n     * Subset is a range row by row\n     */\n    SubsetMode[\"columns\"] = \"BY_ROWS\";\n    /**\n     * Subset is a range column by column\n     */\n    SubsetMode[\"rows\"] = \"BY_COLUMNS\";\n    /**\n     * Subset is a square zone inside the plate\n     */\n    SubsetMode[\"zone\"] = \"ZONE\";\n})(SubsetMode || (SubsetMode = {}));\n/**\n * WellPlate - class representing a well plate\n */\nexport class WellPlate {\n    constructor(config) {\n        this.rows = config.rows;\n        this.columns = config.columns;\n        const { positionFormat = PositionFormat.LetterNumber, iterationOrder = IterationOrder.ByColumn, } = config;\n        this.positionFormat = positionFormat;\n        this.iterationOrder = iterationOrder;\n        this.separator = config.separator || '.';\n        this.size = this.rows * this.columns;\n        this.data = new Array(this.size);\n    }\n    [Symbol.iterator]() {\n        let i = -1;\n        return {\n            next: () => {\n                i++;\n                const done = i === this.size;\n                return {\n                    done,\n                    value: done\n                        ? null\n                        : {\n                            index: i,\n                            position: this._getPositionFromIndex(i, this.iterationOrder),\n                            code: this._getFormattedPosition(i),\n                            data: this.getData(i),\n                        },\n                };\n            },\n        };\n    }\n    _getPositionCode(inputPosition, iterationOrder) {\n        if (typeof inputPosition === 'number') {\n            this._checkIndex(inputPosition);\n            switch (this.positionFormat) {\n                case PositionFormat.Sequential: {\n                    return String(inputPosition + 1);\n                }\n                case PositionFormat.LetterNumber: {\n                    const position = this._getPositionFromIndex(inputPosition, iterationOrder);\n                    return this._letterNumberCodeFromPosition(position);\n                }\n                case PositionFormat.NumberNumber: {\n                    const position = this._getPositionFromIndex(inputPosition, iterationOrder);\n                    return this._numberNumberCodeFromPosition(position);\n                }\n                default: {\n                    /* istanbul ignore next */\n                    throw new Error('Unreachable');\n                }\n            }\n        }\n        else if (typeof inputPosition === 'string') {\n            // This will check if the input is valid\n            const position = this._getPosition(inputPosition);\n            return this._getFormattedPosition(position);\n        }\n        else {\n            this._checkPosition(inputPosition);\n            switch (this.positionFormat) {\n                case PositionFormat.Sequential: {\n                    return this._sequentialCodeFromPosition(inputPosition);\n                }\n                case PositionFormat.LetterNumber: {\n                    return this._letterNumberCodeFromPosition(inputPosition);\n                }\n                case PositionFormat.NumberNumber: {\n                    return this._numberNumberCodeFromPosition(inputPosition);\n                }\n                default: {\n                    /* istanbul ignore next */\n                    throw new Error('Unreachable');\n                }\n            }\n        }\n    }\n    /**\n     * Get the code for a specific position on the well.\n     *\n     * Some wells will return a code compose of a letter and a number\n     * Other will will simply return the position\n     * @param inputPosition - The index position in any valid encoding [[Position]]\n     * @returns The code of the well position. The format depends on the PositionFormat, see [[wellCodeFormat]]\n     */\n    _getFormattedPosition(inputPosition) {\n        return this._getPositionCode(inputPosition, this.iterationOrder);\n    }\n    getPositionSubset(bound1, bound2, mode, encoding) {\n        if (mode === SubsetMode.zone) {\n            return this._getPositionCodeZone(bound1, bound2).map((position) => this.getPosition(position, encoding));\n        }\n        this._checkIndex(this._getIndex(bound1));\n        this._checkIndex(this._getIndex(bound2));\n        const iterationOrder = mode === SubsetMode.columns\n            ? IterationOrder.ByRow\n            : IterationOrder.ByColumn;\n        const b1 = typeof bound1 === 'number' ? this._getPosition(bound1) : bound1;\n        const b2 = typeof bound2 === 'number' ? this._getPosition(bound2) : bound2;\n        let startIndex = this._getOrderedIndex(b1, iterationOrder);\n        let endIndex = this._getOrderedIndex(b2, iterationOrder);\n        if (startIndex > endIndex) {\n            [startIndex, endIndex] = [endIndex, startIndex];\n        }\n        const size = endIndex - startIndex + 1;\n        this._checkIndex(endIndex);\n        return getRange(startIndex, size)\n            .map((index) => {\n            if (iterationOrder !== this.iterationOrder) {\n                return this._getPositionFromIndex(index, iterationOrder);\n            }\n            return index;\n        })\n            .map((pos) => this.getPosition(pos, encoding));\n    }\n    /**\n     * Get a zone of well position codes. A zone is a rectangle in the well plate.\n     * @param bound1 One of the 2 bounding position to include in the zone\n     * @param bound2 The other of the 2 bounding position to include in the zone\n     */\n    _getPositionCodeZone(bound1, bound2) {\n        const startPosition = this._getPosition(bound1);\n        const endPosition = this._getPosition(bound2);\n        this._checkPosition(startPosition);\n        this._checkPosition(endPosition);\n        const upperLeft = {\n            row: Math.min(startPosition.row, endPosition.row),\n            column: Math.min(startPosition.column, endPosition.column),\n        };\n        const bottomRight = {\n            row: Math.max(startPosition.row, endPosition.row),\n            column: Math.max(startPosition.column, endPosition.column),\n        };\n        const width = bottomRight.column - upperLeft.column + 1;\n        const height = bottomRight.row - upperLeft.row + 1;\n        const range = [];\n        for (let j = 0; j < height; j++) {\n            for (let i = 0; i < width; i++) {\n                range.push({\n                    row: upperLeft.row + j,\n                    column: upperLeft.column + i,\n                });\n            }\n        }\n        return range;\n    }\n    _getOrderedIndex(position, iterationOrder) {\n        if (typeof position === 'number') {\n            this._checkIndex(position);\n            return position;\n        }\n        if (typeof position === 'string') {\n            return this._getIndexFromCode(position, iterationOrder);\n        }\n        let index;\n        this._checkPosition(position);\n        if (iterationOrder === IterationOrder.ByColumn) {\n            index = position.row * this.columns + position.column;\n        }\n        else {\n            index = position.column * this.rows + position.row;\n        }\n        return index;\n    }\n    _getIndex(position) {\n        return this._getOrderedIndex(position, this.iterationOrder);\n    }\n    getData(position) {\n        const index = this._getIndex(position);\n        return this.data[index];\n    }\n    setData(position, item) {\n        const index = this._getIndex(position);\n        this.data[index] = item;\n    }\n    getPosition(input, encoding) {\n        switch (encoding) {\n            case 'index': {\n                return this._getIndex(input);\n            }\n            case 'row_column': {\n                return this._getPosition(input);\n            }\n            case 'formatted': {\n                return this._getFormattedPosition(input);\n            }\n            default: {\n                /* istanbul ignore next */\n                throw new Error('unreachable');\n            }\n        }\n    }\n    /**\n     * Get the well position given a formatted well position code.\n     * @param inputPosition The position code.\n     */\n    _getPosition(inputPosition) {\n        if (typeof inputPosition === 'number') {\n            this._checkIndex(inputPosition);\n            return this._getPositionFromIndex(inputPosition, this.iterationOrder);\n        }\n        else if (typeof inputPosition === 'string') {\n            if (this.positionFormat === PositionFormat.NumberNumber) {\n                const reg = /^(?<row>\\d+).(?<column>\\d+)$/;\n                const m = reg.exec(inputPosition);\n                const hasSeparator = inputPosition.includes(this.separator);\n                if (!hasSeparator || m === null || !m.groups) {\n                    throw this._formatError();\n                }\n                const position = {\n                    row: +m.groups.row - 1,\n                    column: +m.groups.column - 1,\n                };\n                this._checkPosition(position);\n                return position;\n            }\n            else {\n                const reg = /^(?<row>[A-Z])(?<column>\\d+)$/;\n                const m = reg.exec(inputPosition);\n                if (m === null || !m.groups) {\n                    if (this.positionFormat !== PositionFormat.Sequential) {\n                        throw this._formatError();\n                    }\n                    const wellIndex = +inputPosition - 1;\n                    if (!Number.isInteger(wellIndex)) {\n                        throw this._formatError();\n                    }\n                    if (Number.isNaN(wellIndex)) {\n                        throw this._formatError();\n                    }\n                    this._checkIndex(wellIndex);\n                    return this._getPositionFromIndex(wellIndex, this.iterationOrder);\n                }\n                if (this.positionFormat !== PositionFormat.LetterNumber) {\n                    throw this._formatError();\n                }\n                const position = {\n                    row: m.groups.row.charCodeAt(0) - 'A'.charCodeAt(0),\n                    column: +m.groups.column - 1,\n                };\n                this._checkPosition(position);\n                return position;\n            }\n        }\n        else {\n            return inputPosition;\n        }\n    }\n    get columnLabels() {\n        const result = [];\n        let label = 1;\n        for (let i = 0; i < this.columns; i++) {\n            result.push(String(label++));\n        }\n        return result;\n    }\n    get rowLabels() {\n        if (this.positionFormat !== PositionFormat.LetterNumber) {\n            const result = [];\n            let label = 1;\n            for (let i = 0; i < this.rows; i++) {\n                result.push(String(label++));\n            }\n            return result;\n        }\n        else {\n            const result = [];\n            let label = 'A'.charCodeAt(0);\n            for (let i = 0; i < this.rows; i++) {\n                result.push(String.fromCharCode(label++));\n            }\n            return result;\n        }\n    }\n    _getPositionFromIndex(index, iterationOrder) {\n        if (iterationOrder === IterationOrder.ByColumn) {\n            return {\n                row: Math.floor(index / this.columns),\n                column: index % this.columns,\n            };\n        }\n        else {\n            return {\n                row: index % this.rows,\n                column: Math.floor(index / this.rows),\n            };\n        }\n    }\n    _getIndexFromCode(formattedPosition, iterationOrder) {\n        return this._getOrderedIndex(this._getPosition(formattedPosition), iterationOrder);\n    }\n    _formatError() {\n        switch (this.positionFormat) {\n            case PositionFormat.LetterNumber: {\n                return new Error('invalid well code format. Must be a letter followed by a number');\n            }\n            case PositionFormat.Sequential: {\n                return new Error('invalid well code format. Must be an integer');\n            }\n            case PositionFormat.NumberNumber: {\n                return new Error(`invalid well code format. Must be 2 numbers separated by a ${this.separator}`);\n            }\n            default: {\n                /* istanbul ignore next */\n                throw new Error('Unreachable');\n            }\n        }\n    }\n    _checkIndex(index) {\n        if (index < 0 || index >= this.size) {\n            throw new RangeError('well position is out of range');\n        }\n    }\n    _checkPosition(position) {\n        if (position.row < 0 ||\n            position.row >= this.rows ||\n            position.column < 0 ||\n            position.column >= this.columns) {\n            throw new RangeError('well position is out of range');\n        }\n    }\n    _sequentialCodeFromPosition(position) {\n        return String(position.row * this.columns + position.column + 1);\n    }\n    _letterNumberCodeFromPosition(position) {\n        const startCharCode = 'A'.charCodeAt(0);\n        const letter = String.fromCharCode(startCharCode + position.row);\n        return letter + (position.column + 1);\n    }\n    _numberNumberCodeFromPosition(position) {\n        return `${position.row + 1}${this.separator}${position.column + 1}`;\n    }\n}\n","import React, {\n  ReactNode,\n  CSSProperties,\n  FunctionComponent,\n  SyntheticEvent,\n} from 'react';\nimport { WellPlate } from 'well-plates';\n\ninterface IWellProps {\n  size: number;\n  value: number;\n  wellPlate: WellPlate;\n  text?: (index: number) => ReactNode;\n  onClick?: (value: number, e: React.MouseEvent) => void;\n  onEnter?: (value: number, e: SyntheticEvent) => void;\n  onLeave?: (value: number, e: SyntheticEvent) => void;\n  onMouseUp?: (value: number, e: React.MouseEvent) => void;\n  onMouseDown?: (value: number, e: React.MouseEvent) => void;\n  style?: CSSProperties;\n  className?: string;\n}\n\nconst wellStyle: CSSProperties = {\n  borderRadius: '50%',\n  borderWidth: 1,\n  borderStyle: 'solid',\n  display: 'flex',\n  alignItems: 'center',\n  textAlign: 'center',\n};\n\nconst Well: FunctionComponent<IWellProps> = (props) => {\n  const { size, style: customStyles } = props;\n\n  const wellMargin = Math.round(size / 12);\n  const style = {\n    ...wellStyle,\n    width: size - 2 * wellMargin,\n    height: size - 2 * wellMargin,\n    margin: wellMargin,\n    ...customStyles,\n  };\n\n  const displayableValue = props.text(props.value);\n\n  return (\n    <div\n      onClick={props.onClick && ((e) => props.onClick(props.value, e))}\n      onMouseEnter={props.onEnter && ((e) => props.onEnter(props.value, e))}\n      onMouseLeave={props.onLeave && ((e) => props.onLeave(props.value, e))}\n      onMouseUp={props.onMouseUp && ((e) => props.onMouseUp(props.value, e))}\n      onMouseDown={\n        props.onMouseDown && ((e) => props.onMouseDown(props.value, e))\n      }\n      className={props.className}\n      style={style}\n    >\n      <div style={{ width: '100%' }}>\n        {displayableValue === undefined\n          ? props.wellPlate.getPosition(props.value, 'formatted')\n          : displayableValue}\n      </div>\n    </div>\n  );\n};\n\nexport default Well;\n","import React, {\n  CSSProperties,\n  FunctionComponent,\n  ReactNode,\n  SyntheticEvent,\n} from 'react';\nimport { WellPlate as WellPlateClass } from 'well-plates';\n\nimport { HeaderCell } from '../WellPlate';\n\nimport Well from './Well';\nimport { IWellPlateCommonProps } from './types';\n\ninterface IWellPlateInternalProps extends IWellPlateCommonProps {\n  plate: WellPlateClass;\n  displayAsGrid?: boolean;\n  onEnter?: (index: number, e: SyntheticEvent) => void;\n  onLeave?: (index: number, e: SyntheticEvent) => void;\n  onMouseDown?: (index: number, e: React.MouseEvent) => void;\n  onMouseUp?: (index: number, e: React.MouseEvent) => void;\n  onClick?: (index: number, e: React.MouseEvent) => void;\n\n  text?: (index: number) => ReactNode;\n  wellClassName?: (index: number) => string | undefined;\n  wellStyle?: (index: number) => CSSProperties;\n\n  headerClassName?: (cell: HeaderCell) => string | undefined;\n  headerStyle?: (cell: HeaderCell) => CSSProperties;\n  headerText?: (cell: HeaderCell) => ReactNode;\n}\n\nconst plateDefaultStyles: CSSProperties = {\n  userSelect: 'none',\n  WebkitUserSelect: 'none',\n};\n\nexport const WellPlateInternal: FunctionComponent<IWellPlateInternalProps> = (\n  props,\n) => {\n  const { displayAsGrid = false } = props;\n\n  if (!displayAsGrid) {\n    return <DefaultWellPlateInternal {...props} />;\n  }\n\n  return <GridWellPlateInternal {...props} />;\n};\n\nfunction GridWellPlateInternal(\n  props: Omit<IWellPlateInternalProps, 'displayAsGrid'>,\n) {\n  const { plate } = props;\n\n  const columnLabels = plate.columnLabels;\n  const rowLabels = plate.rowLabels;\n\n  const cellStyle: CSSProperties = {\n    borderStyle: 'solid',\n    borderColor: 'gray',\n    borderWidth: 1,\n  };\n\n  const values: Array<{\n    index: number;\n    label: string;\n    isHeader: boolean;\n    position: { row: number; column: number };\n  }> = [];\n\n  for (let i = 0; i <= rowLabels.length - 1; i++) {\n    values.push({\n      index: undefined,\n      label: rowLabels[i],\n      isHeader: true,\n      position: { column: -1, row: i },\n    });\n\n    for (let j = 0; j <= columnLabels.length - 1; j++) {\n      const position = { row: i, column: j };\n      const index = plate.getPosition(position, 'index');\n\n      values.push({\n        index,\n        label: plate.getPosition(position, 'formatted'),\n        isHeader: false,\n        position,\n      });\n    }\n  }\n\n  return (\n    <div\n      style={{\n        display: 'grid',\n        gridTemplateColumns: `max-content repeat(${columnLabels.length}, 1fr)`,\n        gridTemplateRows: `max-content repeat(${rowLabels.length}, 1fr)`,\n        ...plateDefaultStyles,\n        ...cellStyle,\n      }}\n    >\n      {[\n        {\n          index: undefined,\n          label: '',\n          isHeader: true,\n          position: { row: -1, column: -1 },\n        },\n        ...columnLabels.map((value, index) => {\n          return {\n            index: undefined,\n            label: value,\n            isHeader: true,\n            position: {\n              row: -1,\n              column: index,\n            },\n          };\n        }),\n        ...values,\n      ].map(({ index, label, isHeader, position }, mapIndex) => {\n        if (isHeader) {\n          const headerCell: HeaderCell = {\n            label,\n            position,\n          };\n\n          const renderHeader = props.headerText?.(headerCell);\n\n          return (\n            <div\n              // eslint-disable-next-line react/no-array-index-key\n              key={`header-${label}-${mapIndex}`}\n              className={props.headerClassName?.(headerCell)}\n              style={{\n                ...cellStyle,\n                ...props.headerStyle?.(headerCell),\n                padding: 5,\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n              }}\n            >\n              {renderHeader === undefined ? label : renderHeader}\n            </div>\n          );\n        }\n\n        const renderText = props.text?.(index);\n\n        return (\n          <div\n            style={{\n              padding: 5,\n              display: 'flex',\n              justifyContent: 'center',\n              alignItems: 'center',\n              ...cellStyle,\n              ...props.wellStyle(index),\n            }}\n            key={index}\n            className={props.wellClassName(index)}\n            onClick={props.onClick && ((e) => props.onClick(index, e))}\n            onMouseEnter={props.onEnter && ((e) => props.onEnter(index, e))}\n            onMouseLeave={props.onLeave && ((e) => props.onLeave(index, e))}\n            onMouseUp={props.onMouseUp && ((e) => props.onMouseUp(index, e))}\n            onMouseDown={\n              props.onMouseDown && ((e) => props.onMouseDown(index, e))\n            }\n          >\n            <div>{renderText === undefined ? label : renderText}</div>\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nfunction DefaultWellPlateInternal(\n  props: Omit<IWellPlateInternalProps, 'displayAsGrid'>,\n) {\n  const { plate, wellSize = 40 } = props;\n\n  const rowLabels = plate.rowLabels;\n  const columnLabels = plate.columnLabels;\n\n  const boxPadding = 4;\n  const boxBorder = 1;\n\n  const headerStyle: CSSProperties = {\n    width: wellSize,\n    textAlign: 'center',\n  };\n\n  const wellStyle: CSSProperties = {\n    width: wellSize,\n    height: wellSize,\n  };\n\n  const rowStyle: CSSProperties = {\n    display: 'flex',\n    alignItems: 'center',\n    height: wellSize,\n  };\n\n  const boxStyle: CSSProperties = {\n    paddingBottom: boxPadding,\n    paddingRight: boxPadding,\n    borderWidth: boxBorder,\n    borderStyle: 'solid',\n    borderColor: 'black',\n    width: wellSize * (plate.columns + 1) + boxPadding + boxBorder,\n    ...plateDefaultStyles,\n  };\n\n  const headerColumnLabels = columnLabels.map((columnLabel, index) => (\n    <div\n      key={columnLabel}\n      style={{\n        ...headerStyle,\n        ...props.headerStyle?.({\n          label: columnLabel,\n          position: {\n            column: index,\n            row: -1,\n          },\n        }),\n      }}\n    >\n      {columnLabel}\n    </div>\n  ));\n\n  const rows = rowLabels.map((rowLabel, rowIdx) => {\n    const columns = columnLabels.map((columnLabel, columnIdx) => {\n      const index = plate.getPosition(\n        { row: rowIdx, column: columnIdx },\n        'index',\n      );\n\n      return (\n        <div key={columnLabel} style={wellStyle}>\n          <Well\n            wellPlate={plate}\n            className={props.wellClassName?.(index)}\n            style={props.wellStyle?.(index)}\n            onClick={props.onClick}\n            onEnter={props.onEnter}\n            onLeave={props.onLeave}\n            onMouseDown={props.onMouseDown}\n            onMouseUp={props.onMouseUp}\n            text={props.text}\n            value={index}\n            size={wellSize}\n          />\n        </div>\n      );\n    });\n\n    return (\n      <div key={rowLabel} style={rowStyle}>\n        <div\n          style={{\n            ...headerStyle,\n            ...props.headerStyle?.({\n              label: rowLabel,\n              position: {\n                column: -1,\n                row: rowIdx,\n              },\n            }),\n          }}\n        >\n          {rowLabel}\n        </div>\n        {columns}\n      </div>\n    );\n  });\n\n  return (\n    <div style={boxStyle}>\n      <div style={rowStyle}>\n        <div style={headerStyle} />\n        {headerColumnLabels}\n      </div>\n      {rows}\n    </div>\n  );\n}\n","import React, {\n  CSSProperties,\n  FunctionComponent,\n  useMemo,\n  useState,\n  useCallback,\n  useEffect,\n  ReactNode,\n} from 'react';\nimport { WellPlate, PositionFormat, SubsetMode } from 'well-plates';\n\nimport { Cell } from './WellPlate';\nimport { WellPlateInternal } from './util/WellPlateInternal';\n\nexport type RangeSelectionMode = 'zone' | 'columns' | 'rows' | 'off';\n\ninterface PickCell extends Cell {\n  disabled: boolean;\n  booked: boolean;\n  selected: boolean;\n}\n\ntype ClassNameParam = (cell: PickCell) => string;\ntype StyleParam = (cell: PickCell) => CSSProperties;\n\nconst defaultWellStyles: CSSProperties = {\n  userSelect: 'none',\n  WebkitUserSelect: 'none',\n  cursor: 'default',\n};\n\nconst defaultWellPickerStyle: StyleParam = ({ booked, disabled, selected }) => {\n  const styles: CSSProperties = {\n    borderColor: 'black',\n  };\n  if (booked) {\n    styles.borderColor = 'orange';\n  }\n  if (disabled) {\n    styles.backgroundColor = 'lightgray';\n  }\n  if (selected) {\n    styles.backgroundColor = 'lightgreen';\n  }\n  return styles;\n};\n\nexport interface IWellPickerProps {\n  displayAsGrid?: boolean;\n  wellSize?: number;\n  rows: number;\n  columns: number;\n  format?: PositionFormat;\n  value: Array<number | string>;\n  disabled?: Array<number | string>;\n  onChange: (value: number[], label: string[]) => void;\n  style?: StyleParam;\n  className?: ClassNameParam;\n  renderText?: (cell: PickCell) => ReactNode;\n  rangeSelectionMode?: RangeSelectionMode;\n  pickMode?: boolean;\n}\n\nexport const MultiWellPicker: FunctionComponent<IWellPickerProps> = ({\n  rows,\n  columns,\n  format,\n  value,\n  renderText: text = ({ label }) => label,\n  disabled = [],\n  onChange,\n  style = defaultWellPickerStyle,\n  className,\n  rangeSelectionMode = 'zone',\n  pickMode = true,\n  ...wellPlateProps\n}) => {\n  const wellPlate = useMemo(() => {\n    return new WellPlate({ rows, columns, positionFormat: format });\n  }, [rows, columns, format]);\n  const valueSet = useMemo(() => {\n    return new Set(value.map((label) => wellPlate.getPosition(label, 'index')));\n  }, [value, wellPlate]);\n  const disabledSet = useMemo(() => {\n    return new Set(\n      disabled.map((label) => wellPlate.getPosition(label, 'index')),\n    );\n  }, [disabled, wellPlate]);\n  const [startWell, setStartWell] = useState<number | null>(null);\n  const [bookedSet, setBooked] = useState(new Set<number>());\n\n  const selectRange = useCallback(\n    (start: number, end: number) => {\n      let range: number[];\n      switch (rangeSelectionMode) {\n        case 'zone': {\n          range = wellPlate.getPositionSubset(\n            start,\n            end,\n            SubsetMode.zone,\n            'index',\n          );\n          break;\n        }\n        case 'columns':\n        case 'rows': {\n          range = wellPlate.getPositionSubset(\n            start,\n            end,\n            rangeSelectionMode === 'columns'\n              ? SubsetMode.columns\n              : SubsetMode.rows,\n            'index',\n          );\n\n          break;\n        }\n        case 'off': {\n          return;\n        }\n        default: {\n          throw new Error('invalid range selection mode');\n        }\n      }\n\n      setBooked(new Set(range));\n    },\n    [rangeSelectionMode, wellPlate],\n  );\n\n  const bookSelection = useCallback(\n    (toggle) => {\n      // if there is no selection, do nothing\n      if (bookedSet.size === 0) return;\n      const newValue = [];\n      for (const bookedEl of bookedSet) {\n        if (!disabledSet.has(wellPlate.getPosition(bookedEl, 'index'))) {\n          if (toggle) {\n            if (!valueSet.has(bookedEl)) {\n              newValue.push(bookedEl);\n            }\n          } else {\n            newValue.push(bookedEl);\n          }\n        }\n      }\n\n      if (toggle) {\n        for (const selected of valueSet) {\n          if (!bookedSet.has(selected)) {\n            newValue.push(selected);\n          }\n        }\n      }\n      onChange(\n        newValue,\n        newValue.map((val) => wellPlate.getPosition(val, 'formatted')),\n      );\n    },\n    [bookedSet, onChange, disabledSet, valueSet, wellPlate],\n  );\n\n  const toggleWell = useCallback(\n    (well: number) => {\n      if (valueSet.has(well)) {\n        const valueSetCopy = new Set(valueSet);\n        valueSetCopy.delete(well);\n        const newValue = Array.from(valueSetCopy);\n        onChange(\n          newValue,\n          newValue.map((val) => wellPlate.getPosition(val, 'formatted')),\n        );\n      } else if (disabledSet.has(well)) {\n        // ignore\n      } else {\n        const newValue = [...valueSet, well];\n        onChange(\n          newValue,\n          newValue.map((val) => wellPlate.getPosition(val, 'formatted')),\n        );\n      }\n    },\n    [valueSet, onChange, disabledSet, wellPlate],\n  );\n\n  const classNameCallback = useCallback<(index: number) => string>(\n    (index) => {\n      if (className) {\n        return className({\n          booked: bookedSet.has(index),\n          disabled: disabledSet.has(index),\n          selected: valueSet.has(index),\n          label: wellPlate.getPosition(index, 'formatted'),\n          position: wellPlate.getPosition(index, 'row_column'),\n          index,\n          wellPlate,\n        });\n      }\n    },\n    [valueSet, bookedSet, disabledSet, className, wellPlate],\n  );\n\n  const textCallback = useCallback<(index: number) => ReactNode>(\n    (index) => {\n      const label = wellPlate.getPosition(index, 'formatted');\n      return text({\n        index,\n        label,\n        wellPlate,\n        booked: bookedSet.has(index),\n        position: wellPlate.getPosition(index, 'row_column'),\n        selected: valueSet.has(index),\n        disabled: disabledSet.has(index),\n      });\n    },\n    [text, wellPlate, bookedSet, valueSet, disabledSet],\n  );\n\n  const styleCallback = useCallback<(index: number) => CSSProperties>(\n    (index) => {\n      return {\n        ...defaultWellStyles,\n        ...style?.({\n          booked: bookedSet.has(index),\n          disabled: disabledSet.has(index),\n          selected: valueSet.has(index),\n          index,\n          label: wellPlate.getPosition(index, 'formatted'),\n          position: wellPlate.getPosition(index, 'row_column'),\n          wellPlate,\n        }),\n      };\n    },\n    [disabledSet, bookedSet, valueSet, style, wellPlate],\n  );\n\n  const clear = useCallback(\n    (event) => {\n      if (event.shiftKey || isCtrlKey(event)) {\n        bookSelection(true);\n      } else {\n        bookSelection(false);\n      }\n      setStartWell(null);\n      setBooked(new Set());\n    },\n    [bookSelection],\n  );\n\n  useEffect(() => {\n    window.addEventListener('mouseup', clear);\n    window.addEventListener('mouseleave', clear);\n    return () => {\n      window.removeEventListener('mouseup', clear);\n      window.removeEventListener('mouseleave', clear);\n    };\n  }, [clear]);\n\n  return (\n    <WellPlateInternal\n      {...wellPlateProps}\n      plate={wellPlate}\n      wellStyle={styleCallback}\n      wellClassName={classNameCallback}\n      text={textCallback}\n      onEnter={(well) => {\n        if (startWell !== null) {\n          selectRange(startWell, well);\n        }\n      }}\n      onLeave={(well) => {\n        if (startWell === well) {\n          selectRange(well, well);\n        }\n      }}\n      onMouseDown={(well, event) => {\n        // if (disabledSet.has(wellPlate.getIndex(well))) return;\n        setStartWell(well);\n        if (!event.shiftKey && !isCtrlKey(event)) {\n          if (!disabledSet.has(wellPlate.getPosition(well, 'index'))) {\n            onChange([well], [wellPlate.getPosition(well, 'formatted')]);\n          } else {\n            onChange([], []);\n          }\n        }\n      }}\n      onClick={(well, e) => {\n        if (e.shiftKey || isCtrlKey(e)) {\n          if (pickMode) {\n            toggleWell(well);\n            e.stopPropagation();\n          }\n        }\n      }}\n    />\n  );\n};\n\nfunction isCtrlKey(event: React.MouseEvent) {\n  if (navigator.platform === 'MacIntel') {\n    return event.metaKey;\n  } else {\n    return event.ctrlKey;\n  }\n}\n","import React, {\n  CSSProperties,\n  FunctionComponent,\n  SyntheticEvent,\n  useMemo,\n  useCallback,\n  ReactNode,\n} from 'react';\nimport {\n  WellPlate as WellPlateClass,\n  PositionFormat,\n  RowColumnPosition,\n} from 'well-plates';\n\nimport { WellPlateInternal } from './util/WellPlateInternal';\nimport { IWellPlateCommonProps } from './util/types';\n\nexport interface Cell {\n  index: number;\n  label: string;\n  wellPlate: WellPlateClass;\n  position: RowColumnPosition;\n}\n\nexport interface HeaderCell {\n  label: string;\n  position: RowColumnPosition;\n}\n\nexport interface IWellPlateProps extends IWellPlateCommonProps {\n  rows: number;\n  columns: number;\n  format?: PositionFormat;\n  displayAsGrid?: boolean;\n\n  wellClassName?: (cell: Cell) => string | undefined;\n  renderText?: (cell: Cell) => ReactNode;\n  wellStyle?: (cell: Cell) => CSSProperties;\n\n  headerClassName?: (cell: HeaderCell) => string | undefined;\n  headerStyle?: (cell: HeaderCell) => CSSProperties;\n  headerText?: (cell: HeaderCell) => ReactNode;\n\n  onClick?: (\n    value: number,\n    label: string,\n    wellPlate: WellPlateClass,\n    e: React.MouseEvent,\n  ) => void;\n  onEnter?: (\n    value: number,\n    label: string,\n    wellPlate: WellPlateClass,\n    e: SyntheticEvent,\n  ) => void;\n  onLeave?: (\n    value: number,\n    label: string,\n    wellPlate: WellPlateClass,\n    e: SyntheticEvent,\n  ) => void;\n  onMouseDown?: (\n    value: number,\n    label: string,\n    wellPlate: WellPlateClass,\n    e: React.MouseEvent,\n  ) => void;\n  onMouseUp?: (\n    value: number,\n    label: string,\n    wellPlate: WellPlateClass,\n    e: React.MouseEvent,\n  ) => void;\n}\n\nexport const WellPlate: FunctionComponent<IWellPlateProps> = (props) => {\n  const {\n    rows,\n    columns,\n    format,\n    onClick,\n    onMouseDown,\n    onMouseUp,\n    onLeave,\n    onEnter,\n    wellStyle,\n    wellClassName,\n    renderText: text,\n    headerStyle,\n    ...otherProps\n  } = props;\n\n  const wellPlate = useMemo(() => {\n    return new WellPlateClass({ rows, columns, positionFormat: format });\n  }, [rows, columns, format]);\n\n  const onClickCallback = useCallback(\n    (value: number, e: React.MouseEvent) => {\n      const label = wellPlate.getPosition(value, 'formatted');\n      if (onClick) onClick(value, label, wellPlate, e);\n    },\n    [onClick, wellPlate],\n  );\n\n  const onMouseDownCallback = useCallback(\n    (value: number, e: React.MouseEvent) => {\n      const label = wellPlate.getPosition(value, 'formatted');\n      if (onMouseDown) onMouseDown(value, label, wellPlate, e);\n    },\n    [onMouseDown, wellPlate],\n  );\n\n  const onLeaveCallback = useCallback(\n    (value: number, e: React.SyntheticEvent) => {\n      const label = wellPlate.getPosition(value, 'formatted');\n      if (onLeave) onLeave(value, label, wellPlate, e);\n    },\n    [onLeave, wellPlate],\n  );\n\n  const onEnterCallback = useCallback(\n    (value: number, e: React.SyntheticEvent) => {\n      const label = wellPlate.getPosition(value, 'formatted');\n      if (onEnter) onEnter(value, label, wellPlate, e);\n    },\n    [onEnter, wellPlate],\n  );\n\n  const wellStyleCallback = useCallback(\n    (index: number): CSSProperties => {\n      const label = wellPlate.getPosition(index, 'formatted');\n      const position = wellPlate.getPosition(index, 'row_column');\n\n      return {\n        userSelect: 'text',\n        WebkitUserSelect: 'text',\n        ...wellStyle?.({ index, label, wellPlate, position }),\n      };\n    },\n    [wellStyle, wellPlate],\n  );\n\n  const headerStyleCallback = useCallback(\n    (cell: HeaderCell): CSSProperties => {\n      return {\n        userSelect: 'text',\n        WebkitUserSelect: 'text',\n        ...headerStyle?.(cell),\n      };\n    },\n    [headerStyle],\n  );\n\n  const wellClassNameCallback = useCallback(\n    (index: number) => {\n      const label = wellPlate.getPosition(index, 'formatted');\n      const position = wellPlate.getPosition(index, 'row_column');\n\n      if (wellClassName) {\n        return wellClassName({ index, label, wellPlate, position });\n      }\n    },\n    [wellClassName, wellPlate],\n  );\n\n  const textCallback = useCallback(\n    (index: number) => {\n      const label = wellPlate.getPosition(index, 'formatted');\n      const position = wellPlate.getPosition(index, 'row_column');\n\n      if (text) return text({ index, label, wellPlate, position });\n      return label;\n    },\n    [text, wellPlate],\n  );\n\n  return (\n    <WellPlateInternal\n      plate={wellPlate}\n      onClick={onClickCallback}\n      text={textCallback}\n      onMouseDown={onMouseDownCallback}\n      onLeave={onLeaveCallback}\n      onEnter={onEnterCallback}\n      wellStyle={wellStyleCallback}\n      wellClassName={wellClassNameCallback}\n      headerStyle={headerStyleCallback}\n      {...otherProps}\n    />\n  );\n};\n"],"names":["f","require$$1","g","reactJsxRuntime_production_min","h","m","n","p","q","c","a","k","b","d","e","l","jsxRuntimeModule","require$$0","getRange","start","size","result","i","PositionFormat","IterationOrder","SubsetMode","WellPlate$1","config","positionFormat","iterationOrder","done","inputPosition","position","bound1","bound2","mode","encoding","b1","b2","startIndex","endIndex","index","pos","startPosition","endPosition","upperLeft","bottomRight","width","height","range","j","item","input","wellIndex","label","formattedPosition","startCharCode","wellStyle","Well","props","customStyles","wellMargin","style","displayableValue","jsx","plateDefaultStyles","WellPlateInternal","displayAsGrid","GridWellPlateInternal","DefaultWellPlateInternal","plate","columnLabels","rowLabels","cellStyle","values","value","isHeader","mapIndex","headerCell","renderHeader","_a","_b","_c","renderText","_d","wellSize","boxPadding","boxBorder","headerStyle","rowStyle","boxStyle","headerColumnLabels","columnLabel","rows","rowLabel","rowIdx","columns","columnIdx","jsxs","defaultWellStyles","defaultWellPickerStyle","booked","disabled","selected","styles","MultiWellPicker","format","text","onChange","className","rangeSelectionMode","pickMode","wellPlateProps","wellPlate","useMemo","WellPlate","valueSet","disabledSet","startWell","setStartWell","useState","bookedSet","setBooked","selectRange","useCallback","end","bookSelection","toggle","newValue","bookedEl","val","toggleWell","well","valueSetCopy","classNameCallback","textCallback","styleCallback","clear","event","isCtrlKey","useEffect","onClick","onMouseDown","onMouseUp","onLeave","onEnter","wellClassName","otherProps","WellPlateClass","onClickCallback","onMouseDownCallback","onLeaveCallback","onEnterCallback","wellStyleCallback","headerStyleCallback","cell","wellClassNameCallback"],"mappings":";;;;;;;GAQsC,IAAIA,EAAEC,EAAiBC,EAAE,MAAMC,EAAA,SAAiB,MAAM,GAAgB,OAAO,QAApB,YAA4B,OAAO,IAAI,CAAC,IAAIC,EAAE,OAAO,IAAIF,EAAEE,EAAE,eAAe,EAAED,EAAA,SAAiBC,EAAE,gBAAgB,CAAC,CAAC,IAAIC,EAAEL,EAAE,mDAAmD,kBAAkBM,EAAE,OAAO,UAAU,eAAeC,EAAE,CAAC,IAAI,GAAG,IAAI,GAAG,OAAO,GAAG,SAAS,EAAE,EACvW,SAASC,EAAEC,EAAEC,EAAEC,EAAE,CAAC,IAAIC,EAAEC,EAAE,GAAGC,EAAE,KAAKC,EAAE,KAAcJ,IAAT,SAAaG,EAAE,GAAGH,GAAYD,EAAE,MAAX,SAAiBI,EAAE,GAAGJ,EAAE,KAAcA,EAAE,MAAX,SAAiBK,EAAEL,EAAE,KAAK,IAAIE,KAAKF,EAAEJ,EAAE,KAAKI,EAAEE,CAAC,GAAG,CAACL,EAAE,eAAeK,CAAC,IAAIC,EAAED,CAAC,EAAEF,EAAEE,CAAC,GAAG,GAAGH,GAAGA,EAAE,aAAa,IAAIG,KAAKF,EAAED,EAAE,aAAaC,EAAWG,EAAED,CAAC,IAAZ,SAAgBC,EAAED,CAAC,EAAEF,EAAEE,CAAC,GAAG,MAAM,CAAC,SAASV,EAAE,KAAKO,EAAE,IAAIK,EAAE,IAAIC,EAAE,MAAMF,EAAE,OAAOR,EAAE,OAAO,CAAC,CAAYF,EAAA,IAACK,EAAEL,EAAA,KAAaK,ECNrVQ,EAAA,QAAiBC,yCCHZ,SAASC,EAASC,EAAOC,EAAM,CAClC,MAAMC,EAAS,CAAA,EACf,QAASC,EAAI,EAAGA,EAAIF,EAAME,IACtBD,EAAOC,CAAC,EAAIH,EAAQG,EAExB,OAAOD,CACX,CCFO,IAAIE,GACV,SAAUA,EAAgB,CAIvBA,EAAe,WAAgB,aAK/BA,EAAe,aAAkB,gBAKjCA,EAAe,aAAkB,eACrC,GAAGA,IAAmBA,EAAiB,CAAE,EAAC,EAKnC,IAAIC,GACV,SAAUA,EAAgB,CAIvBA,EAAe,SAAc,YAI7BA,EAAe,MAAW,QAC9B,GAAGA,IAAmBA,EAAiB,CAAE,EAAC,EACnC,IAAIC,GACV,SAAUA,EAAY,CAInBA,EAAW,QAAa,UAIxBA,EAAW,KAAU,aAIrBA,EAAW,KAAU,MACzB,GAAGA,IAAeA,EAAa,CAAE,EAAC,EAI3B,IAAAC,EAAA,KAAgB,CACnB,YAAYC,EAAQ,CAChB,KAAK,KAAOA,EAAO,KACnB,KAAK,QAAUA,EAAO,QACtB,KAAM,CAAE,eAAAC,EAAiBL,EAAe,aAAc,eAAAM,EAAiBL,EAAe,QAAW,EAAGG,EACpG,KAAK,eAAiBC,EACtB,KAAK,eAAiBC,EACtB,KAAK,UAAYF,EAAO,WAAa,IACrC,KAAK,KAAO,KAAK,KAAO,KAAK,QAC7B,KAAK,KAAO,IAAI,MAAM,KAAK,IAAI,CAClC,CACD,CAAC,OAAO,QAAQ,GAAI,CAChB,IAAIL,EAAI,GACR,MAAO,CACH,KAAM,IAAM,CACRA,IACA,MAAMQ,EAAOR,IAAM,KAAK,KACxB,MAAO,CACH,KAAAQ,EACA,MAAOA,EACD,KACA,CACE,MAAOR,EACP,SAAU,KAAK,sBAAsBA,EAAG,KAAK,cAAc,EAC3D,KAAM,KAAK,sBAAsBA,CAAC,EAClC,KAAM,KAAK,QAAQA,CAAC,CACvB,CACzB,CACa,CACb,CACK,CACD,iBAAiBS,EAAeF,EAAgB,CAC5C,GAAI,OAAOE,GAAkB,SAEzB,OADA,KAAK,YAAYA,CAAa,EACtB,KAAK,eAAc,CACvB,KAAKR,EAAe,WAChB,OAAO,OAAOQ,EAAgB,CAAC,EAEnC,KAAKR,EAAe,aAAc,CAC9B,MAAMS,EAAW,KAAK,sBAAsBD,EAAeF,CAAc,EACzE,OAAO,KAAK,8BAA8BG,CAAQ,CACrD,CACD,KAAKT,EAAe,aAAc,CAC9B,MAAMS,EAAW,KAAK,sBAAsBD,EAAeF,CAAc,EACzE,OAAO,KAAK,8BAA8BG,CAAQ,CACrD,CACD,QAEI,MAAM,IAAI,MAAM,aAAa,CAEpC,SAEI,OAAOD,GAAkB,SAAU,CAExC,MAAMC,EAAW,KAAK,aAAaD,CAAa,EAChD,OAAO,KAAK,sBAAsBC,CAAQ,CAC7C,KAGG,QADA,KAAK,eAAeD,CAAa,EACzB,KAAK,eAAc,CACvB,KAAKR,EAAe,WAChB,OAAO,KAAK,4BAA4BQ,CAAa,EAEzD,KAAKR,EAAe,aAChB,OAAO,KAAK,8BAA8BQ,CAAa,EAE3D,KAAKR,EAAe,aAChB,OAAO,KAAK,8BAA8BQ,CAAa,EAE3D,QAEI,MAAM,IAAI,MAAM,aAAa,CAEpC,CAER,CASD,sBAAsBA,EAAe,CACjC,OAAO,KAAK,iBAAiBA,EAAe,KAAK,cAAc,CAClE,CACD,kBAAkBE,EAAQC,EAAQC,EAAMC,EAAU,CAC9C,GAAID,IAASV,EAAW,KACpB,OAAO,KAAK,qBAAqBQ,EAAQC,CAAM,EAAE,IAAKF,GAAa,KAAK,YAAYA,EAAUI,CAAQ,CAAC,EAE3G,KAAK,YAAY,KAAK,UAAUH,CAAM,CAAC,EACvC,KAAK,YAAY,KAAK,UAAUC,CAAM,CAAC,EACvC,MAAML,EAAiBM,IAASV,EAAW,QACrCD,EAAe,MACfA,EAAe,SACfa,EAAK,OAAOJ,GAAW,SAAW,KAAK,aAAaA,CAAM,EAAIA,EAC9DK,EAAK,OAAOJ,GAAW,SAAW,KAAK,aAAaA,CAAM,EAAIA,EACpE,IAAIK,EAAa,KAAK,iBAAiBF,EAAIR,CAAc,EACrDW,EAAW,KAAK,iBAAiBF,EAAIT,CAAc,EACnDU,EAAaC,IACb,CAACD,EAAYC,CAAQ,EAAI,CAACA,EAAUD,CAAU,GAElD,MAAMnB,EAAOoB,EAAWD,EAAa,EACrC,YAAK,YAAYC,CAAQ,EAClBtB,EAASqB,EAAYnB,CAAI,EAC3B,IAAKqB,GACFZ,IAAmB,KAAK,eACjB,KAAK,sBAAsBY,EAAOZ,CAAc,EAEpDY,CACV,EACI,IAAKC,GAAQ,KAAK,YAAYA,EAAKN,CAAQ,CAAC,CACpD,CAMD,qBAAqBH,EAAQC,EAAQ,CACjC,MAAMS,EAAgB,KAAK,aAAaV,CAAM,EACxCW,EAAc,KAAK,aAAaV,CAAM,EAC5C,KAAK,eAAeS,CAAa,EACjC,KAAK,eAAeC,CAAW,EAC/B,MAAMC,EAAY,CACd,IAAK,KAAK,IAAIF,EAAc,IAAKC,EAAY,GAAG,EAChD,OAAQ,KAAK,IAAID,EAAc,OAAQC,EAAY,MAAM,CACrE,EACcE,EAAc,CAChB,IAAK,KAAK,IAAIH,EAAc,IAAKC,EAAY,GAAG,EAChD,OAAQ,KAAK,IAAID,EAAc,OAAQC,EAAY,MAAM,CACrE,EACcG,EAAQD,EAAY,OAASD,EAAU,OAAS,EAChDG,EAASF,EAAY,IAAMD,EAAU,IAAM,EAC3CI,EAAQ,CAAA,EACd,QAASC,EAAI,EAAGA,EAAIF,EAAQE,IACxB,QAAS5B,EAAI,EAAGA,EAAIyB,EAAOzB,IACvB2B,EAAM,KAAK,CACP,IAAKJ,EAAU,IAAMK,EACrB,OAAQL,EAAU,OAASvB,CAC/C,CAAiB,EAGT,OAAO2B,CACV,CACD,iBAAiBjB,EAAUH,EAAgB,CACvC,GAAI,OAAOG,GAAa,SACpB,YAAK,YAAYA,CAAQ,EAClBA,EAEX,GAAI,OAAOA,GAAa,SACpB,OAAO,KAAK,kBAAkBA,EAAUH,CAAc,EAE1D,IAAIY,EACJ,YAAK,eAAeT,CAAQ,EACxBH,IAAmBL,EAAe,SAClCiB,EAAQT,EAAS,IAAM,KAAK,QAAUA,EAAS,OAG/CS,EAAQT,EAAS,OAAS,KAAK,KAAOA,EAAS,IAE5CS,CACV,CACD,UAAUT,EAAU,CAChB,OAAO,KAAK,iBAAiBA,EAAU,KAAK,cAAc,CAC7D,CACD,QAAQA,EAAU,CACd,MAAMS,EAAQ,KAAK,UAAUT,CAAQ,EACrC,OAAO,KAAK,KAAKS,CAAK,CACzB,CACD,QAAQT,EAAUmB,EAAM,CACpB,MAAMV,EAAQ,KAAK,UAAUT,CAAQ,EACrC,KAAK,KAAKS,CAAK,EAAIU,CACtB,CACD,YAAYC,EAAOhB,EAAU,CACzB,OAAQA,EAAQ,CACZ,IAAK,QACD,OAAO,KAAK,UAAUgB,CAAK,EAE/B,IAAK,aACD,OAAO,KAAK,aAAaA,CAAK,EAElC,IAAK,YACD,OAAO,KAAK,sBAAsBA,CAAK,EAE3C,QAEI,MAAM,IAAI,MAAM,aAAa,CAEpC,CACJ,CAKD,aAAarB,EAAe,CACxB,GAAI,OAAOA,GAAkB,SACzB,YAAK,YAAYA,CAAa,EACvB,KAAK,sBAAsBA,EAAe,KAAK,cAAc,EAEnE,GAAI,OAAOA,GAAkB,SAC9B,GAAI,KAAK,iBAAmBR,EAAe,aAAc,CAErD,MAAMlB,EADM,+BACE,KAAK0B,CAAa,EAEhC,GAAI,CADiBA,EAAc,SAAS,KAAK,SAAS,GACrC1B,IAAM,MAAQ,CAACA,EAAE,OAClC,MAAM,KAAK,eAEf,MAAM2B,EAAW,CACb,IAAK,CAAC3B,EAAE,OAAO,IAAM,EACrB,OAAQ,CAACA,EAAE,OAAO,OAAS,CAC/C,EACgB,YAAK,eAAe2B,CAAQ,EACrBA,CACV,KACI,CAED,MAAM3B,EADM,gCACE,KAAK0B,CAAa,EAChC,GAAI1B,IAAM,MAAQ,CAACA,EAAE,OAAQ,CACzB,GAAI,KAAK,iBAAmBkB,EAAe,WACvC,MAAM,KAAK,eAEf,MAAM8B,EAAY,CAACtB,EAAgB,EACnC,GAAI,CAAC,OAAO,UAAUsB,CAAS,EAC3B,MAAM,KAAK,eAEf,GAAI,OAAO,MAAMA,CAAS,EACtB,MAAM,KAAK,eAEf,YAAK,YAAYA,CAAS,EACnB,KAAK,sBAAsBA,EAAW,KAAK,cAAc,CACnE,CACD,GAAI,KAAK,iBAAmB9B,EAAe,aACvC,MAAM,KAAK,eAEf,MAAMS,EAAW,CACb,IAAK3B,EAAE,OAAO,IAAI,WAAW,CAAC,EAAI,IAAI,WAAW,CAAC,EAClD,OAAQ,CAACA,EAAE,OAAO,OAAS,CAC/C,EACgB,YAAK,eAAe2B,CAAQ,EACrBA,CACV,KAGD,QAAOD,CAEd,CACD,IAAI,cAAe,CACf,MAAMV,EAAS,CAAA,EACf,IAAIiC,EAAQ,EACZ,QAAShC,EAAI,EAAGA,EAAI,KAAK,QAASA,IAC9BD,EAAO,KAAK,OAAOiC,GAAO,CAAC,EAE/B,OAAOjC,CACV,CACD,IAAI,WAAY,CACZ,GAAI,KAAK,iBAAmBE,EAAe,aAAc,CACrD,MAAMF,EAAS,CAAA,EACf,IAAIiC,EAAQ,EACZ,QAAShC,EAAI,EAAGA,EAAI,KAAK,KAAMA,IAC3BD,EAAO,KAAK,OAAOiC,GAAO,CAAC,EAE/B,OAAOjC,CACV,KACI,CACD,MAAMA,EAAS,CAAA,EACf,IAAIiC,EAAQ,IAAI,WAAW,CAAC,EAC5B,QAAShC,EAAI,EAAGA,EAAI,KAAK,KAAMA,IAC3BD,EAAO,KAAK,OAAO,aAAaiC,GAAO,CAAC,EAE5C,OAAOjC,CACV,CACJ,CACD,sBAAsBoB,EAAOZ,EAAgB,CACzC,OAAIA,IAAmBL,EAAe,SAC3B,CACH,IAAK,KAAK,MAAMiB,EAAQ,KAAK,OAAO,EACpC,OAAQA,EAAQ,KAAK,OACrC,EAGmB,CACH,IAAKA,EAAQ,KAAK,KAClB,OAAQ,KAAK,MAAMA,EAAQ,KAAK,IAAI,CACpD,CAEK,CACD,kBAAkBc,EAAmB1B,EAAgB,CACjD,OAAO,KAAK,iBAAiB,KAAK,aAAa0B,CAAiB,EAAG1B,CAAc,CACpF,CACD,cAAe,CACX,OAAQ,KAAK,eAAc,CACvB,KAAKN,EAAe,aAChB,OAAO,IAAI,MAAM,iEAAiE,EAEtF,KAAKA,EAAe,WAChB,OAAO,IAAI,MAAM,8CAA8C,EAEnE,KAAKA,EAAe,aAChB,OAAO,IAAI,MAAM,8DAA8D,KAAK,SAAS,EAAE,EAEnG,QAEI,MAAM,IAAI,MAAM,aAAa,CAEpC,CACJ,CACD,YAAYkB,EAAO,CACf,GAAIA,EAAQ,GAAKA,GAAS,KAAK,KAC3B,MAAM,IAAI,WAAW,+BAA+B,CAE3D,CACD,eAAeT,EAAU,CACrB,GAAIA,EAAS,IAAM,GACfA,EAAS,KAAO,KAAK,MACrBA,EAAS,OAAS,GAClBA,EAAS,QAAU,KAAK,QACxB,MAAM,IAAI,WAAW,+BAA+B,CAE3D,CACD,4BAA4BA,EAAU,CAClC,OAAO,OAAOA,EAAS,IAAM,KAAK,QAAUA,EAAS,OAAS,CAAC,CAClE,CACD,8BAA8BA,EAAU,CACpC,MAAMwB,EAAgB,IAAI,WAAW,CAAC,EAEtC,OADe,OAAO,aAAaA,EAAgBxB,EAAS,GAAG,GAC9CA,EAAS,OAAS,EACtC,CACD,8BAA8BA,EAAU,CACpC,MAAO,GAAGA,EAAS,IAAM,CAAC,GAAG,KAAK,SAAS,GAAGA,EAAS,OAAS,CAAC,EACpE,CACL,EC3WA,MAAAyB,GAAA,CAAiC,aAAA,MACjB,YAAA,EACD,YAAA,QACA,QAAA,OACJ,WAAA,SACG,UAAA,QAEd,EAEAC,EAAAC,GAAA,CACE,KAAA,CAAA,KAAAvC,EAAA,MAAAwC,CAAA,EAAAD,EAEAE,EAAA,KAAA,MAAAzC,EAAA,EAAA,EACA0C,EAAA,CAAc,GAAAL,GACT,MAAArC,EAAA,EAAAyC,EACe,OAAAzC,EAAA,EAAAyC,EACC,OAAAA,EACX,GAAAD,CACL,EAGLG,EAAAJ,EAAA,KAAAA,EAAA,KAAA,EAEA,OAAAK,EACE,MAAC,CAAA,QAAAL,EAAA,UAAA7C,GAAA6C,EAAA,QAAAA,EAAA,MAAA7C,CAAA,GAC+D,aAAA6C,EAAA,UAAA7C,GAAA6C,EAAA,QAAAA,EAAA,MAAA7C,CAAA,GACK,aAAA6C,EAAA,UAAA7C,GAAA6C,EAAA,QAAAA,EAAA,MAAA7C,CAAA,GACA,UAAA6C,EAAA,YAAA7C,GAAA6C,EAAA,UAAAA,EAAA,MAAA7C,CAAA,GACC,YAAA6C,EAAA,cAAA7C,GAAA6C,EAAA,YAAAA,EAAA,MAAA7C,CAAA,GAEL,UAAA6C,EAAA,UAE9C,MAAAG,EACjB,SAAAE,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,MAAA,EAAA,SAAAD,IAAA,OAAAJ,EAAA,UAAA,YAAAA,EAAA,MAAA,WAAA,EAAAI,EAAA,CAMA,CAAA,CAGN,s3CCjCA,MAAAE,EAAA,CAA0C,WAAA,OAC5B,iBAAA,MAEd,EAEOC,EAAAP,GAAA,CAGL,KAAA,CAAA,cAAAQ,EAAA,EAAA,EAAAR,EAEA,OAAAQ,EAIAH,EAAAI,GAAA,CAAA,GAAAT,CAAA,CAAA,EAHEK,EAAAK,GAAA,CAAA,GAAAV,CAAA,CAAA,CAIJ,EAEA,SAAAS,GAAAT,EAAA,CAGE,KAAA,CAAA,MAAAW,CAAA,EAAAX,EAEAY,EAAAD,EAAA,aACAE,EAAAF,EAAA,UAEAG,EAAA,CAAiC,YAAA,QAClB,YAAA,OACA,YAAA,CACA,EAGfC,EAAA,CAAA,EAOA,QAAApD,EAAA,EAAAA,GAAAkD,EAAA,OAAA,EAAAlD,IAAA,CACEoD,EAAA,KAAA,CAAY,MAAA,OACH,MAAAF,EAAAlD,CAAA,EACW,SAAA,GACR,SAAA,CAAA,OAAA,GAAA,IAAAA,CAAA,CACqB,CAAA,EAGjC,QAAA4B,EAAA,EAAAA,GAAAqB,EAAA,OAAA,EAAArB,IAAA,CACE,MAAAlB,EAAA,CAAA,IAAAV,EAAA,OAAA4B,CAAA,EACAT,EAAA6B,EAAA,YAAAtC,EAAA,OAAA,EAEA0C,EAAA,KAAA,CAAY,MAAAjC,EACV,MAAA6B,EAAA,YAAAtC,EAAA,WAAA,EAC8C,SAAA,GACpC,SAAAA,CACV,CAAA,CACD,CACH,CAGF,OAAAgC,EACE,MAAC,CAAA,MAAA,CACQ,QAAA,OACI,oBAAA,sBAAAO,EAAA,MAAA,SACqD,iBAAA,sBAAAC,EAAA,MAAA,SACN,GAAAP,EACrD,GAAAQ,CACA,EACL,SAAA,CAEC,CACC,MAAA,OACS,MAAA,GACA,SAAA,GACG,SAAA,CAAA,IAAA,GAAA,OAAA,EAAA,CACsB,EAClC,GAAAF,EAAA,IAAA,CAAAI,EAAAlC,KAEE,CAAO,MAAA,OACE,MAAAkC,EACA,SAAA,GACG,SAAA,CACA,IAAA,GACH,OAAAlC,CACG,CACV,EACF,EACD,GAAAiC,CACE,EAAA,IAAA,CAAA,CAAA,MAAAjC,EAAA,MAAAa,EAAA,SAAAsB,EAAA,SAAA5C,CAAA,EAAA6C,IAAA,aAEH,GAAAD,EAAA,CACE,MAAAE,EAAA,CAA+B,MAAAxB,EAC7B,SAAAtB,CACA,EAGF+C,GAAAC,EAAArB,EAAA,aAAA,YAAAqB,EAAA,KAAArB,EAAAmB,GAEA,OAAAd,EACE,MAAC,CAAA,WAAAiB,EAAAtB,EAAA,kBAAA,YAAAsB,EAAA,KAAAtB,EAAAmB,GAG8C,MAAA,CACtC,GAAAL,EACF,IAAAS,EAAAvB,EAAA,cAAA,YAAAuB,EAAA,KAAAvB,EAAAmB,GAC8B,QAAA,EACxB,QAAA,OACA,eAAA,SACO,WAAA,QACJ,EACd,SAAAC,IAAA,OAAAzB,EAAAyB,CAEsC,EAAA,UAAAzB,CAAA,IAAAuB,CAAA,EAXN,CAYlC,CAIJ,MAAAM,GAAAC,EAAAzB,EAAA,OAAA,YAAAyB,EAAA,KAAAzB,EAAAlB,GAEA,OAAAuB,EACE,MAAC,CAAA,MAAA,CACQ,QAAA,EACI,QAAA,OACA,eAAA,SACO,WAAA,SACJ,GAAAS,EACT,GAAAd,EAAA,UAAAlB,CAAA,CACqB,EAC1B,UAAAkB,EAAA,cAAAlB,CAAA,EAEoC,QAAAkB,EAAA,UAAA7C,GAAA6C,EAAA,QAAAlB,EAAA3B,CAAA,GACoB,aAAA6C,EAAA,UAAA7C,GAAA6C,EAAA,QAAAlB,EAAA3B,CAAA,GACK,aAAA6C,EAAA,UAAA7C,GAAA6C,EAAA,QAAAlB,EAAA3B,CAAA,GACA,UAAA6C,EAAA,YAAA7C,GAAA6C,EAAA,UAAAlB,EAAA3B,CAAA,GACC,YAAA6C,EAAA,cAAA7C,GAAA6C,EAAA,YAAAlB,EAAA3B,CAAA,GAEL,SAAAkD,EAAA,MAAA,CAAA,SAAAmB,IAAA,OAAA7B,EAAA6B,EAAA,CAGL,EAAA1C,CAV/C,CAWP,CAAA,CAEH,CAAA,CAGP,CAEA,SAAA4B,GAAAV,EAAA,CAGE,KAAA,CAAA,MAAAW,EAAA,SAAAe,EAAA,EAAA,EAAA1B,EAEAa,EAAAF,EAAA,UACAC,EAAAD,EAAA,aAEAgB,EAAA,EACAC,EAAA,EAEAC,EAAA,CAAmC,MAAAH,EAC1B,UAAA,QACI,EAGb5B,EAAA,CAAiC,MAAA4B,EACxB,OAAAA,CACC,EAGVI,EAAA,CAAgC,QAAA,OACrB,WAAA,SACG,OAAAJ,CACJ,EAGVK,EAAA,CAAgC,cAAAJ,EACf,aAAAA,EACD,YAAAC,EACD,YAAA,QACA,YAAA,QACA,MAAAF,GAAAf,EAAA,QAAA,GAAAgB,EAAAC,EACwC,GAAAtB,CAClD,EAGL0B,EAAApB,EAAA,IAAA,CAAAqB,EAAAnD,IAAA,OAAA,OAAAuB,EACE,MAAC,CAAA,MAAA,CAEQ,GAAAwB,EACF,IAAAR,EAAArB,EAAA,cAAA,YAAAqB,EAAA,KAAArB,EAAA,CACoB,MAAAiC,EACd,SAAA,CACG,OAAAnD,EACA,IAAA,EACH,CACP,EACD,EACH,SAAAmD,CAEC,EAAAA,CAZI,EAAA,EAgBTC,EAAArB,EAAA,IAAA,CAAAsB,EAAAC,IAAA,OACE,MAAAC,EAAAzB,EAAA,IAAA,CAAAqB,EAAAK,IAAA,SACE,MAAAxD,EAAA6B,EAAA,YAAoB,CAAA,IAAAyB,EAAA,OAAAE,CAAA,EACe,OACjC,EAGF,OAAAjC,EAAA,MAAA,CAAA,MAAAP,EAAA,SAAAO,EAEIN,EAAC,CAAA,UAAAY,EACY,WAAAU,EAAArB,EAAA,gBAAA,YAAAqB,EAAA,KAAArB,EAAAlB,GAC2B,OAAAwC,EAAAtB,EAAA,YAAA,YAAAsB,EAAA,KAAAtB,EAAAlB,GACR,QAAAkB,EAAA,QACf,QAAAA,EAAA,QACA,QAAAA,EAAA,QACA,YAAAA,EAAA,YACI,UAAAA,EAAA,UACF,KAAAA,EAAA,KACL,MAAAlB,EACL,KAAA4C,CACD,CAAA,CAAA,EAAAO,CAAA,CAEV,CAAA,EAIJ,OAAAM,EAAA,MAAA,CAAA,MAAAT,EAAA,SAAA,CAEIzB,EAAA,MAAC,CAAA,MAAA,CACQ,GAAAwB,EACF,IAAAR,EAAArB,EAAA,cAAA,YAAAqB,EAAA,KAAArB,EAAA,CACoB,MAAAmC,EACd,SAAA,CACG,OAAA,GACA,IAAAC,CACH,CACP,EACD,EACH,SAAAD,CAEC,CAAA,EACHE,CACC,CAAA,EAAAF,CAAA,CACH,CAAA,EAIJ,OAAAI,EAAA,MAAA,CAAA,MAAAR,EAAA,SAAA,CAEIQ,EAAA,MAAA,CAAA,MAAAT,EAAA,SAAA,CACEzB,EAAA,MAAA,CAAA,MAAAwB,CAAA,CAAA,EAAyBG,CACxB,EAAA,EACHE,CACC,CAAA,CAAA,CAGP,i1DCvQA,MAAAM,GAAA,CAAyC,WAAA,OAC3B,iBAAA,OACM,OAAA,SAEpB,EAEAC,GAAA,CAAA,CAAA,OAAAC,EAAA,SAAAC,EAAA,SAAAC,CAAA,IAAA,CACE,MAAAC,EAAA,CAA8B,YAAA,OACf,EAEf,OAAAH,IACEG,EAAA,YAAA,UAEFF,IACEE,EAAA,gBAAA,aAEFD,IACEC,EAAA,gBAAA,cAEFA,CACF,EAkBOC,EAAA,CAAA,CAA8D,KAAAZ,EACnE,QAAAG,EACA,OAAAU,EACA,MAAA/B,EACA,WAAAgC,EAAA,CAAA,CAAA,MAAArD,CAAA,IAAAA,EACkC,SAAAgD,EAAA,CAAA,EACtB,SAAAM,EACZ,MAAA9C,EAAAsC,GACQ,UAAAS,EACR,mBAAAC,EAAA,OACqB,SAAAC,EAAA,GACV,GAAAC,CAEb,IAAA,CACE,MAAAC,EAAAC,EAAAA,QAAA,IACE,IAAAC,EAAA,CAAA,KAAAtB,EAAA,QAAAG,EAAA,eAAAU,CAAA,CAAA,EAA8D,CAAAb,EAAAG,EAAAU,CAAA,CAAA,EAEhEU,EAAAF,EAAAA,QAAA,IACE,IAAA,IAAAvC,EAAA,IAAArB,GAAA2D,EAAA,YAAA3D,EAAA,OAAA,CAAA,CAAA,EAA0E,CAAAqB,EAAAsC,CAAA,CAAA,EAE5EI,EAAAH,EAAAA,QAAA,IACE,IAAA,IAAWZ,EAAA,IAAAhD,GAAA2D,EAAA,YAAA3D,EAAA,OAAA,CAAA,CACoD,EAC/D,CAAAgD,EAAAW,CAAA,CAAA,EAEF,CAAAK,EAAAC,CAAA,EAAAC,EAAA,SAAA,IAAA,EACA,CAAAC,EAAAC,CAAA,EAAAF,EAAAA,SAAA,IAAA,GAAA,EAEAG,EAAAC,EAAA,YAAoB,CAAAzG,EAAA0G,IAAA,CAEhB,IAAA5E,EACA,OAAA6D,EAAA,CAA4B,IAAA,OAAA,CAExB7D,EAAAgE,EAAA,kBAAkB9F,EAChB0G,EACApG,EAAA,KACW,OACX,EAEF,KAAA,CACF,IAAA,UACK,IAAA,OAAA,CAEHwB,EAAAgE,EAAA,kBAAkB9F,EAChB0G,EACAf,IAAA,UAAArF,EAAA,QAAAA,EAAA,KAGe,OACf,EAGF,KAAA,CACF,IAAA,MAEE,OACF,QAEE,MAAA,IAAA,MAAA,8BAAA,CACF,CAGFiG,EAAA,IAAA,IAAAzE,CAAA,CAAA,CAAwB,EAC1B,CAAA6D,EAAAG,CAAA,CAC8B,EAGhCa,EAAAF,EAAA,YAAsBG,GAAA,CAGlB,GAAAN,EAAA,OAAA,EAA0B,OAC1B,MAAAO,EAAA,CAAA,EACA,UAAAC,KAAAR,EACEJ,EAAA,IAAAJ,EAAA,YAAAgB,EAAA,OAAA,CAAA,GACEF,GACEX,EAAA,IAAAa,CAAA,GACED,EAAA,KAAAC,CAAA,EAQR,GAAAF,EACE,UAAAxB,KAAAa,EACEK,EAAA,IAAAlB,CAAA,GACEyB,EAAA,KAAAzB,CAAA,EAINK,EAAAoB,EACEA,EAAA,IAAAE,GAAAjB,EAAA,YAAAiB,EAAA,WAAA,CAAA,CAC6D,CAC/D,EACF,CAAAT,EAAAb,EAAAS,EAAAD,EAAAH,CAAA,CACsD,EAGxDkB,EAAAP,EAAA,YAAmBQ,GAAA,CAEf,GAAAhB,EAAA,IAAAgB,CAAA,EAAA,CACE,MAAAC,EAAA,IAAA,IAAAjB,CAAA,EACAiB,EAAA,OAAAD,CAAA,EACA,MAAAJ,EAAA,MAAA,KAAAK,CAAA,EACAzB,EAAAoB,EACEA,EAAA,IAAAE,GAAAjB,EAAA,YAAAiB,EAAA,WAAA,CAAA,CAC6D,CAC/D,SAAA,CAAAb,EAAA,IAAAe,CAAA,EACgC,CAGhC,MAAAJ,EAAA,CAAA,GAAAZ,EAAAgB,CAAA,EACAxB,EAAAoB,EACEA,EAAA,IAAAE,GAAAjB,EAAA,YAAAiB,EAAA,WAAA,CAAA,CAC6D,CAC/D,CACF,EACF,CAAAd,EAAAR,EAAAS,EAAAJ,CAAA,CAC2C,EAG7CqB,EAAAV,EAAA,YAA0BnF,GAAA,CAEtB,GAAAoE,EACE,OAAAA,EAAA,CAAiB,OAAAY,EAAA,IAAAhF,CAAA,EACY,SAAA4E,EAAA,IAAA5E,CAAA,EACI,SAAA2E,EAAA,IAAA3E,CAAA,EACH,MAAAwE,EAAA,YAAAxE,EAAA,WAAA,EACmB,SAAAwE,EAAA,YAAAxE,EAAA,YAAA,EACI,MAAAA,EACnD,UAAAwE,CACA,CAAA,CAEJ,EACF,CAAAG,EAAAK,EAAAJ,EAAAR,EAAAI,CAAA,CACuD,EAGzDsB,EAAAX,EAAA,YAAqBnF,GAAA,CAEjB,MAAAa,EAAA2D,EAAA,YAAAxE,EAAA,WAAA,EACA,OAAAkE,EAAA,CAAY,MAAAlE,EACV,MAAAa,EACA,UAAA2D,EACA,OAAAQ,EAAA,IAAAhF,CAAA,EAC2B,SAAAwE,EAAA,YAAAxE,EAAA,YAAA,EACwB,SAAA2E,EAAA,IAAA3E,CAAA,EACvB,SAAA4E,EAAA,IAAA5E,CAAA,CACG,CAAA,CAChC,EACH,CAAAkE,EAAAM,EAAAQ,EAAAL,EAAAC,CAAA,CACkD,EAGpDmB,EAAAZ,EAAA,YAAsBnF,IAElB,CAAO,GAAA0D,GACF,GAAArC,GAAA,YAAAA,EAAA,CACQ,OAAA2D,EAAA,IAAAhF,CAAA,EACkB,SAAA4E,EAAA,IAAA5E,CAAA,EACI,SAAA2E,EAAA,IAAA3E,CAAA,EACH,MAAAA,EAC5B,MAAAwE,EAAA,YAAAxE,EAAA,WAAA,EAC+C,SAAAwE,EAAA,YAAAxE,EAAA,YAAA,EACI,UAAAwE,CACnD,EACD,GAEL,CAAAI,EAAAI,EAAAL,EAAAtD,EAAAmD,CAAA,CACmD,EAGrDwB,EAAAb,EAAA,YAAcc,GAAA,CAEVA,EAAA,UAAAC,EAAAD,CAAA,EACEZ,EAAA,EAAA,EAEAA,EAAA,EAAA,EAEFP,EAAA,IAAA,EACAG,EAAA,IAAA,GAAA,CAAmB,EACrB,CAAAI,CAAA,CACc,EAGhBc,OAAAA,EAAAA,UAAA,KACE,OAAA,iBAAA,UAAAH,CAAA,EACA,OAAA,iBAAA,aAAAA,CAAA,EACA,IAAA,CACE,OAAA,oBAAA,UAAAA,CAAA,EACA,OAAA,oBAAA,aAAAA,CAAA,CAA8C,GAChD,CAAAA,CAAA,CAAA,EAGFzE,EACEE,EAAC,CAAA,GAAA8C,EACK,MAAAC,EACG,UAAAuB,EACI,cAAAF,EACI,KAAAC,EACT,QAAAH,GAAA,CAEJd,IAAA,MACEK,EAAAL,EAAAc,CAAA,CACF,EACF,QAAAA,GAAA,CAEEd,IAAAc,GACET,EAAAS,EAAAA,CAAA,CACF,EACF,YAAA,CAAAA,EAAAM,IAAA,CAGEnB,EAAAa,CAAA,EACA,CAAAM,EAAA,UAAA,CAAAC,EAAAD,CAAA,IACErB,EAAA,IAAAJ,EAAA,YAAAmB,EAAA,OAAA,CAAA,EAGExB,EAAA,CAAA,EAAA,CAAA,CAAA,EAFAA,EAAA,CAAAwB,CAAA,EAAA,CAAAnB,EAAA,YAAAmB,EAAA,WAAA,CAAA,CAAA,EAIJ,EACF,QAAA,CAAAA,EAAAtH,IAAA,EAEEA,EAAA,UAAA6H,EAAA7H,CAAA,IACEiG,IACEoB,EAAAC,CAAA,EACAtH,EAAA,gBAAA,EAEJ,CACF,CAAA,CAGN,EAEA,SAAA6H,EAAAD,EAAA,CACE,OAAA,UAAA,WAAA,WACEA,EAAA,QAEAA,EAAA,OAEJ;;;;;;;;;;;;;;6lBCrOO,MAAAvB,EAAAxD,GAAA,CACL,KAAA,CAAM,KAAAkC,EACJ,QAAAG,EACA,OAAAU,EACA,QAAAmC,EACA,YAAAC,EACA,UAAAC,EACA,QAAAC,EACA,QAAAC,EACA,UAAAxF,EACA,cAAAyF,EACA,WAAAvC,EACY,YAAAnB,EACZ,GAAA2D,CACG,EAAAxF,EAGLsD,EAAAC,EAAAA,QAAA,IACE,IAAAkC,EAAA,CAAA,KAAAvD,EAAA,QAAAG,EAAA,eAAAU,CAAA,CAAA,EAAmE,CAAAb,EAAAG,EAAAU,CAAA,CAAA,EAGrE2C,EAAAzB,EAAA,YAAwB,CAAAjD,EAAA7D,IAAA,CAEpB,MAAAwC,EAAA2D,EAAA,YAAAtC,EAAA,WAAA,EACAkE,GAAaA,EAAAlE,EAAArB,EAAA2D,EAAAnG,CAAA,CAAkC,EACjD,CAAA+H,EAAA5B,CAAA,CACmB,EAGrBqC,EAAA1B,EAAA,YAA4B,CAAAjD,EAAA7D,IAAA,CAExB,MAAAwC,EAAA2D,EAAA,YAAAtC,EAAA,WAAA,EACAmE,GAAiBA,EAAAnE,EAAArB,EAAA2D,EAAAnG,CAAA,CAAsC,EACzD,CAAAgI,EAAA7B,CAAA,CACuB,EAGzBsC,EAAA3B,EAAA,YAAwB,CAAAjD,EAAA7D,IAAA,CAEpB,MAAAwC,EAAA2D,EAAA,YAAAtC,EAAA,WAAA,EACAqE,GAAaA,EAAArE,EAAArB,EAAA2D,EAAAnG,CAAA,CAAkC,EACjD,CAAAkI,EAAA/B,CAAA,CACmB,EAGrBuC,EAAA5B,EAAA,YAAwB,CAAAjD,EAAA7D,IAAA,CAEpB,MAAAwC,EAAA2D,EAAA,YAAAtC,EAAA,WAAA,EACAsE,GAAaA,EAAAtE,EAAArB,EAAA2D,EAAAnG,CAAA,CAAkC,EACjD,CAAAmI,EAAAhC,CAAA,CACmB,EAGrBwC,EAAA7B,EAAA,YAA0BnF,GAAA,CAEtB,MAAAa,EAAA2D,EAAA,YAAAxE,EAAA,WAAA,EACAT,EAAAiF,EAAA,YAAAxE,EAAA,YAAA,EAEA,MAAA,CAAO,WAAA,OACO,iBAAA,OACM,GAAAgB,GAAA,YAAAA,EAAA,CAAA,MAAAhB,EAAA,MAAAa,EAAA,UAAA2D,EAAA,SAAAjF,CAAA,EACkC,CACtD,EACF,CAAAyB,EAAAwD,CAAA,CACqB,EAGvByC,EAAA9B,EAAA,YAA4B+B,IAExB,CAAO,WAAA,OACO,iBAAA,OACM,GAAAnE,GAAA,YAAAA,EAAAmE,EACG,GAEzB,CAAAnE,CAAA,CACY,EAGdoE,EAAAhC,EAAA,YAA8BnF,GAAA,CAE1B,MAAAa,EAAA2D,EAAA,YAAAxE,EAAA,WAAA,EACAT,EAAAiF,EAAA,YAAAxE,EAAA,YAAA,EAEA,GAAAyG,EACE,OAAAA,EAAA,CAAA,MAAAzG,EAAA,MAAAa,EAAA,UAAA2D,EAAA,SAAAjF,CAAA,CAAA,CACF,EACF,CAAAkH,EAAAjC,CAAA,CACyB,EAG3BsB,EAAAX,EAAA,YAAqBnF,GAAA,CAEjB,MAAAa,EAAA2D,EAAA,YAAAxE,EAAA,WAAA,EACAT,EAAAiF,EAAA,YAAAxE,EAAA,YAAA,EAEA,OAAAkE,EAAUA,EAAA,CAAA,MAAAlE,EAAA,MAAAa,EAAA,UAAA2D,EAAA,SAAAjF,CAAA,CAAA,EACVsB,CAAO,EACT,CAAAqD,EAAAM,CAAA,CACgB,EAGlB,OAAAjD,EACEE,EAAC,CAAA,MAAA+C,EACQ,QAAAoC,EACE,KAAAd,EACH,YAAAe,EACO,QAAAC,EACJ,QAAAC,EACA,UAAAC,EACE,cAAAG,EACI,YAAAF,EACF,GAAAP,CACT,CAAA,CAGV","x_google_ignoreList":[0,1,2,3]}